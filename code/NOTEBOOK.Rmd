---
title: "My MANUAL on RStudio"
output:
  word_document: default
  pdf_document:
    latex_engine: lualatex
  html_document: default
---

 
Данные для работы можно готовить в любой программе, я предпочитаю таблицы в Ворде переводить в текст с разделителями  запятыми и сохранять файл в формате *.txt. При этом десятичный разделитель разрядов в значениях точка (0.23).
Работать лучше в RNotebook и запускать все команды оттуда

**Данные, с которыми вы собираетесь работать, как и файл .Rmd должны храниться в одной дериктории**

##Загрузка данных
```
rev<-read.table(file = "all_rev.txt", sep = ",", header = T)
```
### Загрузка таблиц Excel
Осуществляется при помощи библиотеки xlsx.
Сначала указывается путь к файлу, затем читается определённый лист из книги Excel
```{r}
library(xlsx)
Ch="c:/Users/Tom/Dropbox/статистика/J Soils Sediments/stat/PCA/Check.xlsx"
Ch=read.xlsx(Ch, 1) # 1 - номер листа в файле который нужно загрузить
```


## Выгрузка данных
### В формат "xlsx"

**Обязательно проверить наличие Java той же версии (32 или 64 бита) что и R**
Файл сохраняется в рабочей директории, которая установлена в данный момент. 

```
library(rJava)
library(xlsx)
Загрузка требуемого пакета: xlsxjars
write.xlsx(Mcor, "m.xlsx") #Mcor- массив данных, "m.xlsx" - имя файла для сохранения
```
Функция работает для **ДАТАФРЕЙМОВ** если нужно выгрузить результат ANOVA или Tukey HSD нужно действовать через функцию do.call
```
El=do.call("rbind", Esta) # по сnолбцам
El=do.call("cbind", Esta) # по строкам
```

###Сохранение и чтение  датафрейма как объекта Rdata
Иногда нужно поделиться готовым датафреймом с коллегами, чтобы не утруждать их загрузкой и чтением таблиц
в этом случае помогает команда 
```
save(Ep, file="Ep.rdata")
Ep <- get(load("C:/Users/Tom/Dropbox/статистика/J Soils Sediments/stat/PCA/Ep.rdata"))# чтение
```

##Общие команды для просмотра данных и проверка класса данных

###Просмотреть структуру датафрейма
```
str(El) 
'data.frame':	21 obs. of  28 variables:
 $ point: Factor w/ 7 levels "30","31","32",..: 1 1 1 2 2 2 3 3 3 4 ...
 $ L    : Factor w/ 3 levels "a","b","c": 1 2 3 1 2 3 1 2 3 1 ...
 $ Li   : num  26.6 53.1 10.2 20.1 25.8 ...
 $ Be   : num  1.06 1.4 1.35 1.31 2.75 2.22 1.42 1.48 1.41 0.9 ...
 .
 .
 $ U    : num  1.07 1.26 0.64 1.07 1.84 1.83 1.32 1.11 0.78 0.95 ...
```
####Проверка класса данных
Указывается переменная из массива, класс которой вы хотите определить

```
class(EL$layer)
```

###данные - в фактор
```
rev$depth<-as.factor(rev$depth)OM
```
команда меняет класс переменной в самом массиве не создавая новый

# Описательная статистика
Функция "describe" из пакета psych позволяет получить основные параметры описательной статистики по массиву
```
library(psych)
Descp=describeBy(Prall, Prall$layer)# Вариант группового вычисления описательной статитстики не разбивая массив Prall на таблицы по слоям, группирующей перемнной является "layer"
library(xlsx)
write.xlsx(DescElA, "ElA.xlsx")
```
По функции 'Descp=' R создаёт объект с результатами описательной статистики, и выгружает в эксель функцией write.xlsx
Если нужны описательные статистики без разбивки по слоям, то нужно использовать функцию describe (без By)

```
Elab.mat=describe(elab, skew="FALSE")
```



```
Descp2<-do.call("cbind",Descp)
write.xlsx(Descp2, "Des.xlsx")
```
"cbind" или "rbind" формирует данные по колонкам или по строкам и делает таблицу, которая может быть выгружена в Excel.


Можно сделать subset для каждого слоя и рассчитать описательные статистики отдельно с помощью команд указанных ниже:
```
Prallo<-subset(Prall, layer=="o")
Pralla<-subset(Prall, layer=="a")
Prallab<-subset(Prall, layer=="ab")
Prallb<-subset(Prall, layer=="b")
Prallbc<-subset(Prall, layer=="bc")
describe(Prallo)
describe(Pralla)
describe(Prallab)
describe(Prallb)
describe(Prallbc)
```
### Сводная таблица описательной статистики всего массива
Результат работы функции describeBy может быть оформлен в виде таблицы для удобной обработки в сторонних программах. 
Кроме того, describeBy может формировать несколько группирующих переменных одновременно.

```
prall.mat <- describeBy(Prall, Prall$layer, skew=FALSE, ranges=FALSE, mat=TRUE)
prall.mat
```
###**SUBSET** Извлеченые данных из таблицы по функции **SUBSET()**
```
U<-subset(rev, species=="U")

```
U - новый объект, subset - извлечение, rev - массив откуда извлекаем, species==U имя переменной и значение по которому будет произведен subset.
```
L<-subset(rev, species=="L")

```
Если хотим **исключить** все строки с какой-то переменной то
```
L<-subset(rev, species != "L")# знак ! исключает переменную из массива
```
Если хотим **удалить определённый столбец**
```
Ep=subset(Ep,  select = -c(16, 43)) #d скобках указываем номера колонок 
```
Если хотим **выбрать из таблицы** только строки с определённым значением какого-либо параметра
```
subset(Ep, C > 10, select = c(1:28))#1

subset(Ep, C > 10)#2
```
В 1 случае выбрали из колонок в диапазоне с 1 по 28-ю все строки, в которых значение переменной "С" было больше 10.

Во 2-м случае выбрали все строки где "С" было больше 10 в результат вошли все столбцы все столбцы массива Ер

###Проверка нормальности распределения данных
  
```
shapiro.test(OM$c)
```

Если p менее 0,05 значит данные рапределены ненормально

```
qqnorm(OM$c)
```

Если данные выстраиваются в ровную линию под углом близким к 45 градусам, - данные распределены нормально

Для ненормальных данных применяется процедура Бокса-Кокса (трансформирование). Для работы нужен пакет "forecast". Для начала вычисляется лямбда (l) по которой будет произведено трансформирование. Так, при l=2 исходные значения трансформируемой переменной будут возведены в квадрат, при l=0.5 будет извлечен квадратный корень, а при l= менее 1 будут рассчитаны обратные значения, при l=0 будет выполнено логарифмирование исходных данных. Параметр "l" может принимать произвольные положительные или отрицательные значения. 

```
library(forecast)
lambda=BoxCox.lambda(OM$c)
[1] 0.1683615
```
первая часть команды стандартная (OM - название массива данных; знак доллара- связь; с- переменная которую нужно трансформировать; lambda-команда вызывает результат вычисления лямбды, в данном случе она равна [1] 0.1683615
```
trans.data=BoxCox(OM$c, 0.1683615)> trans.data 
```
название вновь создаваемого массива данных; BoxCox- команда; (OM$c, 0.1683615) (название исходного массива $ трансформируемая переменная, лямбда. вычесленная на предыдущем этапе)
trans.data - просмотр итога трансформации, если р менее 0,05, прежде чем делать вывод о ненормальности данных нужно проверить гомогенность груповых дисперсий при помощи теста ЛЕВЕНЕ.

###Трансформация данных и добавление переменных в существующий массив данных
Для работы нужен пакет forecast
```
library(forecast)
lambda=BoxCox.lambda(OM10$bd)
lambda
OM10bdtr<-BoxCox(OM10$bd, 0.24754)
shapiro.test(OM10bdtr)
```
проверка на нормальность результата трансформации
####Добавление переменных в таблицу

OM10p<-within(OM10, { # OM10p<- имя нового массива; within -команда вставки столбца (OM10, в какой массив вставлять
        phht<-OM10phhtr # phht<- имя нового столбца; OM10phhtr - отдельно созданный массив, из которого создаётся 
        phkt<-OM10phktr # колонка, в нашем случае трансформированная переменная. так с новой строки записываются
        })              # команды для создаваемых переменных и массивы из которых их создают, завершается команда фигурной скобкой с новой строки и простой скобкой. 
Пример
```
OM10p<-within(OM10, { 
        phht<-OM10phhtr 
        phkt<-OM10phktr
        bdt<- OM10bdtr
})
```
В примере выше добавили три колонки с изменёнными по Боксу-Коксу данными
###Создания столбца с результатом вычисления существующих
ch$chamg<-ch[,4]*100 # "ch"- массив в который добавляется новая колонка "chamg" полученная путём умножения колонки всех значений в колонке № 4 на 100


###Удаление переменных (столбцов) из массива данных

```
M<-names(OM10t) %in% c("dep", "phh", "phk", "bd") 
```
Создаём Value: M<-names-команда (OM10t)- имя массива откуда нужно удалить переменные %in% c ("plot", "c", "n") - имя переменных которые нужно удалить

```
M1<-OM10t[!M] 
```
Создаём массив данных с именем М1 <-OM10t- имя массива данных откуда нужно убрать данные М [!M]- команда удаления перменных перечисленных в объекте М созданном выше.

###Удаление строк из массива данных

Для работы нужна библиотека (ggplot2) # сомнительно на компьютере Абрамовой функция работала без ggplot2

```
library(ggplot2)
OM20f<-OM20[c(1:3,5:20), ]
```
OM20f- имя вновь создаваемого массива <-OM20- имя трансформируемого массива [c(1:3,5:20)- дипазоны строк которые нужно оставить в новом массиве, можно через запятую приводить и отдельные номера строк (порядковые номера!!!!, а не те, что нумерует программа); 

,  ] - пробел после запятой и ] означают, что в новый массив войдут все стобцы (переменные), если нужно оставить только определённые нужно прописать и их в кавычках

###Удаление столбцов из массива
```
OM20f<-OM20[, c(2:15, 16)]
```
[,  квадратная скобка и пробел после запятой означают, что в новый массив войдут все строки, и столбцы в диапазоне с(2:15, 17) со 2 по 15-ю и 17-я строка

### Добавление/удаление столбцов/строк в массив

```
Sp=Sp[c(1:14), ]# удалили последние 2 строки из таблицы со свойствами т.к. они относились к 37 разрезу, в котором м/э  не определялись
Ep=cbind(El,Sp) #присоеденили столбцы Sp к El
```
### Слияние двух столбцов
```{r}
MIX$x <- paste(MIX$Mixplot,MIX$day)# В массиве MIX добавили колонку "x" которая является результатом слияния колонок 'Mixplot' и 'day'
```
### Выбор диапазона для анализа данных
FECOLN [1:7, c(2:13, 29:30)] строки с 1 по 7ю и колонки со 2 по 13 потом с 29 по 30. в массиве FECOLN


###Удаление данных из среды R

```{r}
rm(Ep, и т.д.)
```



###Транспонирование массива
Поворот массива на бок осуществляется командой t

```
Ert=t(Er)
```
###Редактирование данных в столбце/строке
Первая команда редактирования данных
Вторая прикрепление нового столбца/строки к существующему массиву
```
Bae=edit(Ep$Ba) #столбец в массиве Ep
Bae=edit(Ep[, 5]) #5-я строка в массиве Ep
Ep=within(Ep, {
Ba=Bae
}) #заменили исходный столбец Ba на изменённый Bae
#для добавления строки в массив нужно воспользоваться функцией rbind
Ep=rbind(Ep,Bae) #присоеденили трансформированную 5-ю строку к Ep
```
#### Переименование строк таблицы

rownames(имя массива)
el<- необходимый столбец(имя массива) или el<- имя массива$необходимый столбец
rownames(имя массива)<- el

```
rownames(Ep) # проверка существующих имён
el<- layer(Ep) или el<- Ep$layer # создание объекта из конкретного столбца
rownames(Ep)<- el #присвоение имён строкам в таблице из созданного выше объекта
```

##Загрузка рисунка в протокол RNotebook
Загрузка рисунка в отчёт осуществляется посредством команды 

```
![]()
![Рисунок 1](C:\Users\Tom\Documents\r_stat\syntax.jpg)
```
где ! - команда вставить рисунок, 
[Подпись, которая появится под рисунком] 
(путь к рисунку на компьютере) или (url ссылка из интернета)

### Построение графика средних величин какой-либо переменной по слоям
Команда(массив$переменная~массив$фактор, массив$фактор, подпись оси "у", подпись оси "х")

```
boxplot(El$Li~El$L, El$L, ylab="Li(ppm)", xlab="layers")
```
### Построение  графика по коэф. варьирования

```
attach(dataset)#присоединили данные
plot(N, VA, type="p", xaxt="n", pch=21, col="green", ann=FALSE, ylim = c(0, 100))#переменные по х, по у, тип- точка, нет подписей, тип знака, цвет знака, легенда, пределы оси у
lines(N, VB, type="p", pch=15, col="brown") #доп ряд данных по переменной VB
axis(1, at=N, labels = E, las=0, cex.axis=0.7)

```

#КОРРЕЛЯЦИЯ
Создание матрицы корреляционных коэффициентов и построение таблицы с цветовым отображением коррелирующих переменных
Для построения нужна библиотека "corrplot"

```
library(corrplot)
Mcor=cor(El[,c(3:8)])
#новый массив=cor(массив[,c(диапазон с 3 по 8 колонку, можно добавить через запятую только нужные колонки)])
corrplot(Mcor, method = "color", addCoef.col = " darkgreen", order = "FPC", addgrid.col = "gray33", tl.col = "black")
#corrplot(имя матрицы корреляционных коэффициентов, method = "color"# как выделить отрицательные и положительные коэффициенты корреляции, addCoef.col = "цвет самих коэффициентов в матрице", order = "упорядочивание по принципу факторного анализа", addgrid.col = "цвет сетки огрничивающей отдельные коэффициенты", tl.col = "цвет переменных по бокам и сверху"))

```
параметр order	
"original" for original order (default).
"AOE" for the angular order of the eigenvectors.
"FPC" for the first principal component order.
"hclust" for the hierarchical clustering order.
"alphabet" for alphabetical order.

#ДАНН тест
для части массива
```{r Данн тест по части массива}
dunn.test(x=Lossl$Cot[which(Lossl$day=="365"&Lossl$species=="mix")] , g=Lossl$treat[which(Lossl$day=="365"&Lossl$species=="mix")] , method="holm", kw=TRUE)
```

```{r Фильтр по Dplyr на ходу анализа на примере wilcox.test}
wilcox.test(Col~day, paired=F, data=Lossl%>% # тест однофакторный, поэтому фактор должен иметь только 2 уровня
              filter(day !="0"& day !="218"& treat !="control")) 

```

